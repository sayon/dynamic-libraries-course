\documentclass[xcolor={usenames,dvipsnames}]{beamer}

\mode<presentation> { }

\usetheme{metropolis}
\usepackage{listings}
\usepackage{polyglossia}
\setmainlanguage{english}


\usepackage[numbers]{natbib}

\usepackage{tikz}
\usetikzlibrary{arrows, decorations.pathmorphing,backgrounds,fit,positioning,shapes.symbols,chains, positioning,automata}

\usepackage{lstc}
\usepackage{lstnasm}
\usepackage{lstshell}
\renewcommand{\lstcurrentinputdir}{listings}

\usepackage{tikz}
\usetikzlibrary{arrows,
decorations.pathmorphing,backgrounds,fit,positioning,shapes.symbols,chains,
positioning,automata,positioning,calc}

\tikzset{onslide/.code args={<#1>#2}{%
  \only<#1>{\pgfkeysalso{#2}} % \pgfkeysalso doesn't change the path
}}

\makeatletter
\newenvironment<>{btHighlight}[1][]
{\begin{onlyenv}#2\begingroup\tikzset{bt@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\bt@HL@box[bt@Highlight@par]{\@tempboxa}\endgroup\end{onlyenv}}

\newcommand<>\btHL[1][]{%
  \only#2{\begin{btHighlight}[#1]\bgroup\aftergroup\bt@HL@endenv}%
}


\def\bt@HL@endenv{%
  \end{btHighlight}%   
  \egroup
}

\newcommand{\bt@HL@box}[2][]{%
  \tikz[#1]{%
    \pgfpathrectangle{\pgfpoint{1pt}{0pt}}{\pgfpoint{\wd #2}{\ht #2}}%
    \pgfusepath{use as bounding box}%
    \node[anchor=base west, fill=orange!30,outer sep=0pt,inner xsep=1pt, inner ysep=0pt, rounded corners=3pt, minimum height=\ht\strutbox+1pt,#1]{\raisebox{1pt}{\strut}\strut\usebox{#2}};
  }%
}

\makeatother



%settings 
\everymath{\displaystyle}

\title{Dynamic libraries explained }
\subtitle{as seen by a low-level programmer}
\author{I.Zhirkov}

\date{2017}
\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=false,rounded=false]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}


%\AtBeginSection[]
%{
%  \begin{frame}<beamer>{\secname}
%    \tableofcontents[currentsection, currentsubsection,
%      subsectionstyle=show/show/hide, sectionstyle=show/show]
%  \end{frame}
%}


\iffalse
Этот мини-курс посвящен устройству динамических библиотек на низком уровне в современном 64-разрядном окружении. Будут рассмотрены следующие вопросы:

— Зачем нужен компоновщик и динамический загрузчик. 
— Релокация. 
— Структура ELF-файлов: секции, сегменты. Таблицы символов. 
— Отличие статического и динамического связывания. 
— Position Independent Code.
— Global Offset Table и Program Linkage Table. 
— Как описывается интерфейс динамических библиотек. 
— Процесс разрешения символов. 
— Оптимизация динамических библиотек. 
— Small, Medium, Large Code Models и как они изменяются в условиях Position Independent Code. 

\fi

\begin{document}

\begin{frame}
  \titlepage
\end{frame}




\begin{frame}{Exemplary environment}
    \begin{itemize} 
        \item  Intel 64 aka AMD64 aka x86\_64.
        \item  GNU/Linux
        \item  Object file format: ELF files.
        \item Languages: C, Assembly (NASM)
\end{itemize} 
\end{frame}

\begin{frame}{Contents}
\tableofcontents

\end{frame}

\section{Preface}
\subsection{Relocation}

\begin{frame}{\subsecname}
    \begin{itemize}
 \item  Compiling is not trivial.
 \item  One of challenges -- carefully placing code and data in memory.
\end{itemize} 
\end{frame}

\begin{frame}[fragile]{Example}

    \begin{tabular}{p{5.3cm} l}
        {
        
\begin{cexample}
int x;
int* y = &x;

void f() {
    x = x + 1;
}
\end{cexample}


        \only<2>{
       
\begin{itemize}
    \item  Where to place \c{x} and \c{y}?
    \item  Code and data require knowing addresses. 
    \item  \emph{Once an address is picked, it is difficult to change.}
\end{itemize}

        }

        }&{
            \raisebox{-\height}{\includegraphics[scale=0.3]{images/relocation-1.png}

       ~

       ~

        }


        }
        \\
        & 
        \only<1>{\small{ {\color{red} red} -- depends on positioning}} 
    \end{tabular}

\end{frame}



\begin{frame}{Solution: linking stage}
    \begin{itemize}

        \item Last stage of compilation: linking.
        \item  Defer placement until linking.
            \begin{itemize}
                \item  Instructions generated, we know all functions and global variables.
            \end{itemize} 
        \item  \textbf{Symbol} -- program entities which are useful for linking.
            \begin{itemize}
                \item Global variables.
                \item Functions.
                \item Utility symbols.
            \end{itemize} 
\end{itemize} 
    
    

\end{frame}



\begin{frame}[fragile]{Symbols}

For each symbol we know its:
    \begin{itemize}

        \item  Name.
        \item  Address if assigned.
        \item  Locations where referenced.
\end{itemize} 
     Assigning addresses to symbols is called \textbf{relocation}.

\begin{cexample}
int x;          // symbol 'x'

void func() {      // symbol 'f'
    x = x + 1;  // symbol 'x' referenced
}
\end{cexample}


\end{frame}

\subsection{Linker}
\begin{frame}{\subsecname}
    
    \textbf{Linker} is a program that assigns addresses to symbols and finalizes
    compilation.
    
    Allows for separate compilation, which we need:
    
    \begin{itemize}
        \item Programs too big for one file (split into modules).
        \item Using already compiled code (libraries).
        \item Fast debugging (each change invokes recompilation).
            \begin{itemize}
                \item  Some programs take \emph{hours} to compile from scratch.
            \end{itemize}
    \end{itemize} 

\end{frame}



\begin{frame}{Compilation pipeline}
    \includegraphics[height=\textheight]{images/compilation.png} 
\end{frame}


\begin{frame}[fragile]{Modules and objects}
    Compiler works with atomic code entities called \textbf{modules}.
   
    In C, module is a \sh{.c} file.
    
    Modules are transformed into \textbf{object files}.
    
Object files are structured and contain translated instructions.


\end{frame}

\begin{frame}{ELF object files}
\textbf{ELF} -- Executable and Linkable Format, typical for *nix systems.

Can be:

\begin{enumerate}
\item \textbf{Relocatable} object files
    
    {\small \texttt{.o}-files, produced by compiler, not linked.}

    {\small Same as \textbf{static libraries}}.

\item \textbf{Executable} object file 
    
    {\small program after linking, ready-to-run.}

\item \textbf{Shared} 
   
    {\small \texttt{.so}, dynamic libraries, to be linked in runtime.}

\end{enumerate}

    \begin{description}
        \item[Static linker] transforms 1 into 2 or 3.
        \item[Dynamic linker] prepares 3 for execution.
    \end{description}

\end{frame}


\section{Static linking}

\subsection{ELF format}


\begin{frame}{Toolset}
    Tools to examine object files:
    \begin{itemize}
\item  \sh{readelf} -- perfect for ELF files
\item  \sh{objdump} -- general purpose, disassembler
\item  \sh{nm} -- only symbols.
\end{itemize} 

    Stick with \sh{readelf}, use \sh{objdump} for disassembly.

\end{frame}

\begin{frame}{ELF file structure}
        Three headers:
        \begin{itemize}
            \item  File header 
                \begin{itemize}
                    \item  General info.
                    \item  Links to Program and Section headers.
                \end{itemize} 
            \item  Section header
                \begin{itemize}
                    \item Information about \textbf{sections}.
                    \item Each section stores code or meta-information.
                    \item Needed for linking.
                \end{itemize} 
            \item  Program header
                \begin{itemize}
                    \item  Instructions on how to create process image.
                    \item  Information about \textbf{segments}.
                    \item  Segment is a virtual memory region;
                        contains some sections.

                    \item Needed for execution.
                \end{itemize} 
        \end{itemize} 
\end{frame}


\begin{frame}[fragile]
    \begin{tabular}{p{5cm} p{5cm}}
       
            
            \raisebox{-\height}{\includegraphics[scale=0.3]{images/elf-structure-general.png}}
            
        & {
            ~

Typical sections:
            
            \begin{itemize}
                \item \textbf{.data}
                \item \textbf{.text} -- compiled instructions.
                \item \textbf{.rodata} -- read only data.
                \item \textbf{.bss} -- zero-initialized data (only size).
                \item \textbf{.line} -- line numbers in source code.
                \item \textbf{.symtab} -- all symbols from source code.

            \end{itemize} 

        }
    \end{tabular}
\end{frame}

\begin{frame}[fragile]{Exemplary program}
  
    \begin{asmexample}
section .data         ; global variables:
x dq 148842           ; int  x = 148842
y dq datavar1         ; int* y = &x

extern somewhere      ; an external symbol 
global _start         ; visible to other modules

section .text         ; code:  {
  _start: 
    mov rax, x        ; rax := &x
    mov rdx, y        ; rdx := &y

  jmp _start          ; } while (true);
    \end{asmexample}

\end{frame}


\begin{frame}[fragile]{ELF File Header}

    \begin{shell}
> nasm -f elf64 symb.asm -o symb.o  # compile 
> ld -o symb symb.o                 # link
> readelf -h  symb             # view file header
    \end{shell}

Class:                             ELF64

Type:                              EXEC (Executable file)

Entry point address:               0x4000c0

Start of program headers:          56 (bytes into file)

Start of section headers:          584 (bytes into file)

Number of program headers:         2

Number of section headers:         6
\end{frame}


\begin{frame}[fragile]{Sections -- before linking}
    \begin{shell}
> readelf -S symb.o
    \end{shell}

{\small
\setlength{\parindent}{-0.5cm}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l l l l l l l l l l }
\textbf{Name}& \textbf{Type} & \textbf{Address} & \textbf{Offset} & \textbf{Size}& \textbf{EntSize} & \textbf{Flags} & \textbf{Link} & \textbf{Info} & \textbf{Align} \\
.data & PROGBITS   & 0 & 240  & 10 & 0 & WA & 0 & 0 & 4 \\
.text & PROGBITS   & 0 & 250  & 16 & 0 & AX & 0 & 0 & 16 \\
.shstrtab & STRTAB & 0 & 270  & 3d & 0 & 0  & 0 & 0 & 1  \\
.symtab   & SYMTAB & 0 & 2b   & c0 & 18& 0  & 5 & 6 & 4  \\
.strtab   & STRTAB & 0 & 370  & 2d & 0 & 0  & 0 & 0 & 1  \\
.rela.data& RELA   & 0 & 3a0  & 18 & 18& 0  & 4 & 1 & 4 \\
.rela.text& RELA   & 0 & 3c0  & 30 & 18& 0  & 4 & 2 & 4 \\

\end{tabular}
}
\pause
    \begin{itemize}
        \item  All addresses are 0
    \end{itemize}
\end{frame}

\begin{frame}{Mapping sections into memory}
   
    \includegraphics[scale=0.28]{images/segments-to-memory.png}
\end{frame}
\iffalse

Start with studying ELF format because it is illustrative
Structure of object files
Sections, Segments 
show symbol tables, relocation
practice: needed tools, Example C, Example ASM

Shared libraries 
\fi



%\begin{frame}[allowframebreaks]
%\frametitle{References}
%\bibliography{biblio} 
%\end{frame}


\iffalse
Litterature:
my book
ABI
Ulrich drepper
\fi
\end{document}


